import httpx
import json
import re
import logging
from typing import Dict, List, Any, Set, Optional, Tuple
from urllib.parse import urlparse
import asyncio

from .tool_decorator import recon_tool

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger("waf_detector")

# WAF signatures to detect
WAF_SIGNATURES = {
    'Cloudflare': [
        {'headers': {'server': 'cloudflare'}, 'cookies': ['__cfduid', 'cf_clearance']},
        {'error_page': ['cloudflare ray id:', 'cloudflare to restrict access', 'performance & security by cloudflare']}
    ],
    'AWS WAF': [
        {'headers': {'x-amzn-waf-': ''}, 'cookies': ['awsalb', 'awsalbcors']},
        {'error_page': ['aws web application firewall', 'request id:']}
    ],
    'Imperva/Incapsula': [
        {'headers': {'x-iinfo': '', 'incap-client-ip': ''}, 'cookies': ['incap_ses', 'visid_incap']},
        {'error_page': ['powered by incapsula', 'incapsula incident']}
    ],
    'Akamai': [
        {'headers': {'x-akamai-': '', 'akamai-origin-hop': ''}, 'cookies': ['ak_bmsc']},
        {'error_page': ['access denied | akamai technologies', 'akamai error page']}
    ],
    'Sucuri': [
        {'headers': {'x-sucuri-': ''}, 'cookies': ['sucuri_cloudproxy']},
        {'error_page': ['sucuri website firewall', 'access denied - sucuri']}
    ],
    'Fastly': [
        {'headers': {'fastly-debug-digest': '', 'x-served-by': 'cache'}, 'cookies': []},
        {'error_page': ['fastly error', 'generated by fastly']}
    ],
    'ModSecurity': [
        {'headers': {'server': 'modsecurity'}, 'cookies': []},
        {'error_page': ['modsecurity', 'application firewall error', 'error 403 forbidden']}
    ],
    'F5 BIG-IP ASM': [
        {'headers': {'server': 'big-ip'}, 'cookies': ['TS', 'BIGipServer']},
        {'error_page': ['the requested url was rejected', 'request rejected', 'f5 networks']}
    ],
    'Barracuda': [
        {'headers': {'barra_counter_session': ''}, 'cookies': []},
        {'error_page': ['barracuda web application firewall', 'barra_counter_session']}
    ],
    'Wordfence': [
        {'headers': {}, 'cookies': ['wfvt_', 'wordfence']},
        {'error_page': ['generated by wordfence', 'wordfence security', 'blocked by wordfence']}
    ],
    'Fortinet': [
        {'headers': {'set-cookie': 'FORTIWAFSID='}, 'cookies': ['FORTIWAFSID']},
        {'error_page': ['powered by fortinet', 'fortigate application control', 'application firewall']}
    ],
    'DDoS-Guard': [
        {'headers': {'server': 'ddos-guard'}, 'cookies': []},
        {'error_page': ['ddos-guard', 'protected by ddos-guard']}
    ],
    'Radware': [
        {'headers': {}, 'cookies': ['radware_appwall']},
        {'error_page': ['request rejected by xss filter', 'unauthorized activity has been detected']}
    ],
    'Citrix WAF': [
        {'headers': {'set-cookie': 'ns_af='}, 'cookies': ['citrix_ns_id', 'ns_af']},
        {'error_page': ['access forbidden! request forbidden by administrative rules', 'citrix']}
    ],
    'SiteLock': [
        {'headers': {}, 'cookies': []},
        {'error_page': ['sitelock is blocking this activity', 'secure by sitelock', 'website security by sitelock']}
    ],
}

@recon_tool
async def detect_waf(url: str, timeout: int = 10, user_agent: str = None, 
                    test_payloads: bool = True) -> Dict[str, Any]:
    """
    Detects if a Web Application Firewall (WAF) is protecting a website and attempts to identify it.
    
    Args:
        url: The URL to check for WAF protection
        timeout: Connection timeout in seconds
        user_agent: Custom User-Agent string to use (defaults to a standard browser)
        test_payloads: Whether to use test payloads to trigger WAF responses
        
    Returns:
        Dictionary with WAF detection results
    """
    # Ensure URL has a scheme
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url
    
    # Set up results
    results = {
        'target': url,
        'waf_detected': False,
        'identified_wafs': [],
        'fingerprints': [],
        'confidence_level': 'None',
        'bypass_suggestions': []
    }
    
    # Set default UA if not provided
    if not user_agent:
        user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    
    # Headers to use for requests
    headers = {
        'User-Agent': user_agent,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        'Connection': 'close',
        'Upgrade-Insecure-Requests': '1',
        'Cache-Control': 'no-cache',
    }
    
    try:
        # 1. Check the normal response first
        async with httpx.AsyncClient(timeout=timeout, follow_redirects=True) as client:
            # First normal request
            normal_resp = await client.get(url, headers=headers)
            
            # Analyze response headers and cookies for WAF fingerprints
            detected_by_headers = await _check_headers_for_waf(normal_resp.headers, normal_resp.cookies.items())
            results['fingerprints'].extend(detected_by_headers)
            
            # If test_payloads is true, try some common attack payloads to trigger WAF responses
            if test_payloads:
                # Try with SQL injection payload
                sql_headers = headers.copy()
                sql_headers['Referer'] = f"{url}' OR 1=1 --"
                
                try:
                    sql_resp = await client.get(f"{url}?id=1' OR '1'='1", headers=sql_headers)
                    detected_by_sql = await _check_for_waf_response(sql_resp)
                    results['fingerprints'].extend(detected_by_sql)
                except Exception as e:
                    # Connection error might indicate WAF blocking
                    results['fingerprints'].append(f"Connection error with SQL injection payload: {str(e)}")
                
                # Try with XSS payload 
                xss_headers = headers.copy()
                xss_headers['Referer'] = f"{url}<script>alert(1)</script>"
                
                try:
                    xss_resp = await client.get(f"{url}?s=<script>alert(1)</script>", headers=xss_headers)
                    detected_by_xss = await _check_for_waf_response(xss_resp)
                    results['fingerprints'].extend(detected_by_xss)
                except Exception as e:
                    # Connection error might indicate WAF blocking
                    results['fingerprints'].append(f"Connection error with XSS payload: {str(e)}")
                
                # Try with LFI payload
                lfi_headers = headers.copy()
                
                try:
                    lfi_resp = await client.get(f"{url}?file=../../../etc/passwd", headers=lfi_headers)
                    detected_by_lfi = await _check_for_waf_response(lfi_resp)
                    results['fingerprints'].extend(detected_by_lfi)
                except Exception as e:
                    # Connection error might indicate WAF blocking
                    results['fingerprints'].append(f"Connection error with LFI payload: {str(e)}")
            
            # Remove duplicate fingerprints
            results['fingerprints'] = list(set(results['fingerprints']))
            
            # Check if we detected WAF fingerprints
            if results['fingerprints']:
                results['waf_detected'] = True
                
                # Identify specific WAFs
                waf_match_count = {}
                for waf_name, fingerprint in await _identify_waf(results['fingerprints']):
                    if waf_name not in waf_match_count:
                        waf_match_count[waf_name] = 0
                    waf_match_count[waf_name] += 1
                
                # Sort by most matches and add to results
                for waf_name, count in sorted(waf_match_count.items(), key=lambda x: x[1], reverse=True):
                    if count > 0:
                        results['identified_wafs'].append(waf_name)
                
                # Set confidence level
                if not results['identified_wafs']:
                    results['confidence_level'] = 'Low (Generic WAF)'
                elif len(results['fingerprints']) >= 3:
                    results['confidence_level'] = 'High'
                else:
                    results['confidence_level'] = 'Medium'
                
                # Generate bypass suggestions
                results['bypass_suggestions'] = await _generate_bypass_suggestions(results['identified_wafs'])
                
    except Exception as e:
        logger.error(f"Error in WAF detection: {str(e)}")
        # If we got an error, it might be a WAF blocking our request
        results['waf_detected'] = True
        results['confidence_level'] = 'Low (Error-based detection)'
        results['fingerprints'].append(f"Error during detection: {str(e)}")
    
    return results

async def _check_headers_for_waf(headers: Dict[str, str], cookies: List[Tuple[str, str]]) -> List[str]:
    """Check headers and cookies for WAF fingerprints"""
    fingerprints = []
    
    # Convert headers to lowercase for easier matching
    headers_lower = {k.lower(): v for k, v in headers.items()}
    
    # Check for specific WAF headers
    for header_name, header_value in headers_lower.items():
        # Cloud WAFs
        if 'cloudflare' in header_name or 'cloudflare' in str(header_value).lower():
            fingerprints.append(f"Cloudflare header: {header_name}")
        
        if 'incap' in header_name or 'incap' in str(header_value).lower():
            fingerprints.append(f"Incapsula/Imperva header: {header_name}")
        
        if 'x-sucuri-' in header_name:
            fingerprints.append(f"Sucuri header: {header_name}")
        
        if 'akamai' in header_name or 'akamai' in str(header_value).lower():
            fingerprints.append(f"Akamai header: {header_name}")
        
        if 'x-iinfo' in header_name:
            fingerprints.append("Incapsula header: x-iinfo")
        
        if header_name == 'server' and 'cloudflare' in str(header_value).lower():
            fingerprints.append("Cloudflare server header")
        
        if header_name == 'server' and 'bigip' in str(header_value).lower():
            fingerprints.append("F5 BIG-IP server header")
        
        if header_name == 'server' and 'ddos-guard' in str(header_value).lower():
            fingerprints.append("DDoS-Guard server header")
        
        # AWS WAF (amazon)
        if any(x in header_name for x in ['x-amz-', 'x-amzn-', 'x-amz-cf-']):
            fingerprints.append(f"AWS/CloudFront header: {header_name}")
        
        # ModSecurity
        if header_name == 'server' and 'modsecurity' in str(header_value).lower():
            fingerprints.append("ModSecurity server header")
        
        # Fastly
        if 'fastly' in header_name or 'fastly' in str(header_value).lower():
            fingerprints.append(f"Fastly header: {header_name}")
    
    # Check cookies
    cookie_names = [name.lower() for name, _ in cookies]
    
    if any('cf_' in c for c in cookie_names) or '__cfduid' in cookie_names or 'cf_clearance' in cookie_names:
        fingerprints.append("Cloudflare cookie detected")
    
    if any('incap_' in c for c in cookie_names) or 'visid_incap' in cookie_names:
        fingerprints.append("Incapsula cookie detected")
    
    if any('bigip' in c.lower() for c in cookie_names) or any('ts_' in c.lower() for c in cookie_names):
        fingerprints.append("F5 BIG-IP cookie detected")
    
    if 'aws' in ''.join(cookie_names) or 'alb' in ''.join(cookie_names):
        fingerprints.append("AWS cookie detected")
    
    if 'wp-' in ''.join(cookie_names) and any('wordfence' in c for c in cookie_names):
        fingerprints.append("Wordfence (WordPress) cookie detected")
    
    if any('ak_bmsc' in c for c in cookie_names):
        fingerprints.append("Akamai cookie detected")
    
    if any('sucuri_' in c for c in cookie_names):
        fingerprints.append("Sucuri cookie detected")
    
    if any('fortiwafsid' in c.lower() for c in cookie_names):
        fingerprints.append("Fortinet cookie detected")
    
    return fingerprints

async def _check_for_waf_response(response) -> List[str]:
    """Check if the response indicates a WAF block"""
    fingerprints = []
    
    # First check response code
    if response.status_code in [403, 406, 429, 503]:
        fingerprints.append(f"WAF-typical status code: {response.status_code}")
    
    # Check response content for WAF signatures
    content = response.text.lower()
    
    # Common WAF block messages in content
    common_waf_strings = [
        'access denied', 'blocked', 'security', 'firewall', 'attack', 'malicious',
        'illegal', 'forbidden', 'unauthorized', 'not allowed', 'suspicious', 
        'security policy violation', 'waf', 'intrusion', 'violated', 'violation',
        'protection', 'defended', 'blocked for security reasons', 'our security policy'
    ]
    
    for waf_string in common_waf_strings:
        if waf_string in content:
            fingerprints.append(f"WAF block message: '{waf_string}'")
    
    # Check for specific WAFs in content
    if 'cloudflare' in content:
        fingerprints.append("Cloudflare WAF block page")
    
    if 'incapsula' in content:
        fingerprints.append("Incapsula WAF block page")
    
    if 'imperva' in content:
        fingerprints.append("Imperva WAF block page")
    
    if 'akamai' in content:
        fingerprints.append("Akamai WAF block page")
    
    if 'sucuri' in content:
        fingerprints.append("Sucuri WAF block page")
    
    if 'wordfence' in content:
        fingerprints.append("Wordfence WAF block page")
    
    if 'fortinet' in content or 'fortigate' in content:
        fingerprints.append("Fortinet WAF block page")
    
    if 'barracuda' in content:
        fingerprints.append("Barracuda WAF block page")
    
    if 'f5' in content or 'big-ip' in content:
        fingerprints.append("F5 BIG-IP WAF block page")
    
    if 'citrix' in content:
        fingerprints.append("Citrix WAF block page")
    
    if 'modsecurity' in content:
        fingerprints.append("ModSecurity WAF block page")
    
    if 'aws' in content and 'waf' in content:
        fingerprints.append("AWS WAF block page")
    
    return fingerprints

async def _identify_waf(fingerprints: List[str]) -> List[Tuple[str, str]]:
    """Match fingerprints to specific WAF products"""
    waf_matches = []
    
    # Map of signatures to WAF products
    waf_signature_map = {
        'Cloudflare': ['cloudflare', 'cf_', '__cfduid', 'cf_clearance'],
        'Imperva/Incapsula': ['incapsula', 'imperva', 'incap_', 'visid_incap', 'x-iinfo'],
        'AWS WAF': ['amazon', 'aws', 'x-amz', 'x-amzn', 'alb', 'x-amz-cf'],
        'Akamai': ['akamai', 'ak_bmsc'],
        'Sucuri': ['sucuri'],
        'ModSecurity': ['modsecurity', 'mod_security'],
        'F5 BIG-IP ASM': ['f5', 'big-ip', 'bigip', 'ts_'],
        'Wordfence': ['wordfence'],
        'Fortinet': ['fortinet', 'fortigate', 'fortiwafsid'],
        'Barracuda': ['barracuda'],
        'Citrix WAF': ['citrix', 'ns_af', 'citrix_ns_id'],
        'Fastly': ['fastly'],
        'DDoS-Guard': ['ddos-guard'],
        'SiteLock': ['sitelock']
    }
    
    # Check each fingerprint against WAF signatures
    for fingerprint in fingerprints:
        fp_lower = fingerprint.lower()
        for waf_name, signatures in waf_signature_map.items():
            for sig in signatures:
                if sig.lower() in fp_lower:
                    waf_matches.append((waf_name, fingerprint))
    
    return waf_matches

async def _generate_bypass_suggestions(identified_wafs: List[str]) -> List[str]:
    """Generate suggestions for potential WAF bypass techniques"""
    suggestions = []
    
    # General suggestions
    general_suggestions = [
        "Use a VPN or proxy to change your IP address if it's been blocked",
        "Try changing your User-Agent header to mimic a different browser",
        "Encode or obfuscate the payload using different encoding techniques",
        "Use HTTP parameter pollution (add multiple instances of the same parameter)",
        "Try HTTP verb tampering (using different HTTP methods like PUT, OPTIONS)",
        "Test for case-sensitivity in WAF rule matching"
    ]
    
    # Add a few general suggestions
    suggestions.extend(general_suggestions[:3])
    
    # WAF-specific suggestions
    waf_specific = {
        'Cloudflare': [
            "Wait for some time as Cloudflare's temporary blocks expire",
            "Use legitimate-looking request patterns",
            "Try connecting from a different IP address (non-datacenter)",
            "Use techniques to bypass rate limiting (gradual request rate)"
        ],
        'AWS WAF': [
            "Try escape sequence variations for SQL injection bypass",
            "Test URL encoded characters to bypass pattern matching",
            "AWS WAF may have stricter rules for /api/ paths than other paths"
        ],
        'Imperva/Incapsula': [
            "Request original site (non-WAF IP) if possible",
            "Test the URL exclusion list (some paths may not be protected)",
            "Try combinations of URL encoding to bypass pattern matching"
        ],
        'ModSecurity': [
            "Test for rule-specific bypasses by analyzing error responses",
            "Try different SQL comment styles for bypassing SQL injection rules",
            "Try PCRE regex engine limitations to bypass rules"
        ],
        'F5 BIG-IP ASM': [
            "Test for JSON/XML parsing differences",
            "Try parameter pollution with different encodings",
            "F5 may treat specific headers differently (Host, Content-Type)"
        ]
    }
    
    # Add WAF-specific suggestions for identified WAFs
    for waf in identified_wafs:
        if waf in waf_specific:
            suggestions.extend(waf_specific[waf][:2])  # Add up to 2 specific suggestions
    
    # Don't return too many suggestions
    if len(suggestions) > 5:
        return suggestions[:5]
    
    return suggestions

# Example usage
if __name__ == "__main__":
    results = asyncio.run(detect_waf("cloudflare.com"))
    print(json.dumps(results, indent=2)) 